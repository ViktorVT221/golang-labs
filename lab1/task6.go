package main

import "fmt"

func main() {
	var x, y, z uint8 // Оголошуємо змінні типу uint8 (8-бітні беззнакові цілі числа)

	x = 9  // Присвоюємо x значення 9 (00001001 у двійковому вигляді)
	y = 28 // Присвоюємо y значення 28 (00011100 у двійковому вигляді)
	z = x  // Зберігаємо початкове значення x у змінній z

	fmt.Println("Бітові операції")

	// Оператор ^ інвертує всі біти числа x
	fmt.Printf("^x      = ^(%d)      = ^(%.8b)            = %.8b = %d\n", x, x, ^x, ^x)
	// x = 9 -> 00001001, інверсія бітів дає 11110110 (246 у десятковій формі)

	// Оператор << зсуває біти числа вліво на 2 позиції (множить число на 2^2 = 4)
	fmt.Printf("x << 2  = (%d << 2)  = (%.8b << 2)        = %.8b = %d\n", x, x, x<<2, x<<2)
	// 00001001 << 2 -> 00100100 (36 у десятковій формі)

	// Оператор >> зсуває біти числа вправо на 2 позиції (ділить число на 2^2 = 4)
	fmt.Printf("x >> 2  = (%d >> 2)  = (%.8b >> 2)        = %.8b = %d\n", x, x, x>>2, x>>2)
	// 00001001 >> 2 -> 00000010 (2 у десятковій формі)

	// Побітовий AND (&) зберігає біти у 1, якщо вони дорівнюють 1 в обох числах
	fmt.Printf("x & y   = (%d & %d)  = (%.8b & %.8b)  = %.8b = %d\n", x, y, x, y, x&y, x&y)
	// 00001001 & 00011100 -> 00001000 (8 у десятковій формі)

	// Побітовий OR (|) встановлює біт у 1, якщо хоча б один з бітів дорівнює 1
	fmt.Printf("x | y   = (%d | %d)  = (%.8b | %.8b)  = %.8b = %d\n", x, y, x, y, x|y, x|y)
	// 00001001 | 00011100 -> 00011101 (29 у десятковій формі)

	// Побітовий XOR (^) встановлює біт у 1, якщо біти різні
	fmt.Printf("x ^ y   = (%d ^ %d)  = (%.8b ^ %.8b)  = %.8b = %d\n", x, y, x, y, x^y, x^y)
	// 00001001 ^ 00011100 -> 00010101 (21 у десятковій формі)

	// Оператор &^ (AND NOT) встановлює біти у 0, якщо відповідний біт у другому числі дорівнює 1
	fmt.Printf("x &^ y  = (%d &^ %d) = (%.8b &^ %.8b) = %.8b = %d\n", x, y, x, y, x&^y, x&^y)
	// 00001001 &^ 00011100 -> 00000001 (1 у десятковій формі)

	// Обчислюємо остачу від ділення x на y
	fmt.Printf("x %% y   = (%d %% %d)  = (%.8b %% %.8b)  = %.8b = %d\n", x, y, x, y, x%y, x%y)
	// 9 % 28 -> 9 (оскільки 9 < 28)

	fmt.Println("\nБітові операції з присвоюванням")

	// Побітове AND з присвоєнням: x = x & y
	x = z
	x &= y
	fmt.Printf("x &= y   = (%d &= %d)  = (%.8b &= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	// 00001001 &= 00011100 -> 00001000 (8)

	// Побітове OR з присвоєнням: x = x | y
	x = z
	x |= y
	fmt.Printf("x |= y   = (%d |= %d)  = (%.8b |= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	// 00001001 |= 00011100 -> 00011101 (29)

	// Побітове XOR з присвоєнням: x = x ^ y
	x = z
	x ^= y
	fmt.Printf("x ^= y   = (%d ^= %d)  = (%.8b ^= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	// 00001001 ^= 00011100 -> 00010101 (21)

	// Побітове AND NOT з присвоєнням: x = x &^ y
	x = z
	x &^= y
	fmt.Printf("x &^= y  = (%d &^= %d) = (%.8b &^= %.8b) = %.8b = %d\n", z, y, z, y, x, x)
	// 00001001 &^= 00011100 -> 00000001 (1)

	// Обчислення остачі з присвоєнням: x = x % y
	x = z
	x %= y
	fmt.Printf("x %%= y   = (%d %%= %d)  = (%.8b %%= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	// 9 %= 28 -> 9 (оскільки 9 < 28)
}
